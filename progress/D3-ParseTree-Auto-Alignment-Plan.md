# D3.js 自动对齐方案调研与新组件集成计划

## 1. D3.js 树状布局基础与算法比较

*   **`d3.hierarchy()`**: 这是 D3.js 层次布局的基础。它将扁平或嵌套的数据转换为一个层次结构，每个节点都包含其父节点、子节点、深度和值等信息。这是进行树状布局的第一步。
*   **`d3.tree()` - 矩形布局 (默认)**:
    *   **特点**: 节点以矩形坐标系（x, y）排列，通常父节点在上方，子节点在下方，兄弟节点水平排列。
    *   **对齐**: 默认会尝试将兄弟节点居中对齐，并确保节点不重叠。它通过一个“分离”（separation）函数来控制兄弟节点之间的最小距离。
    *   **优点**: 直观，易于理解，适合表示传统的自上而下或自左向右的层次结构。
    *   **缺点**: 当树的宽度很大时，可能需要很大的水平空间；深度很深时，可能需要很大的垂直空间。
    *   **适用场景**: 大多数解析树、文件系统结构、组织架构图等。
*   **`d3.tree()` - 径向布局**:
    *   **特点**: 节点以极坐标系（角度，半径）排列，根节点在中心，子节点沿径向向外扩散，兄弟节点沿角度方向排列。
    *   **对齐**: 节点沿圆形路径对齐，兄弟节点均匀分布在圆弧上。
    *   **优点**: 空间利用率高，尤其适合展示具有多个分支的树，视觉上更具吸引力。
    *   **缺点**: 对于非常深的树，径向布局可能导致外层节点过于密集；对于习惯矩形布局的用户来说，可能需要一些适应时间。
    *   **适用场景**: 生物分类树、族谱图、某些网络拓扑图等。
*   **节点大小**: 可以通过 `tree.nodeSize()` 或 `tree.size()` 来设置每个节点占据的空间大小，这会影响整体布局和对齐。

## 2. 自定义对齐策略

虽然 `d3.tree()` 提供了良好的默认对齐，但在某些情况下，您可能需要更精细的控制：

*   **调整 `separation` 函数**: `tree.separation()` 函数允许您自定义兄弟节点之间的间距。您可以根据节点的特定属性（例如，节点文本的长度）来动态调整间距，以避免文本重叠并改善视觉效果。
    *   例如，对于具有不同宽度文本的节点，可以根据文本宽度调整分离值，确保即使文本很长，节点也不会重叠。
*   **后处理节点坐标**: 在 `d3.tree()` 计算出初始坐标后，您可以遍历所有节点，并根据自定义逻辑微调它们的 `x` 或 `y` 坐标。这对于实现特定的对齐规则（例如，所有叶子节点在同一水平线上）非常有用。
    *   **居中对齐**: 如果您希望某个层级的所有节点都严格居中对齐，可以在布局完成后计算该层级的总宽度，然后调整每个节点的 `x` 坐标。
    *   **特定节点组对齐**: 对于解析树中具有特定语义的节点组，您可以编写逻辑来将它们对齐。
*   **使用 `d3-flextree` (第三方库)**: 如果 `d3.tree()` 的默认行为无法满足需求，可以考虑使用像 `d3-flextree` 这样的第三方库。它提供了更灵活的节点大小和间距控制，可以更好地处理不同大小节点的对齐问题。

## 3. 力导向图的考虑 (可选)

*   **`d3-force`**: 力导向图 (`d3-force`) 适用于更通用的图布局，其中节点之间的连接关系比严格的层次结构更重要。它通过模拟物理力（如引力、斥力）来定位节点。
*   **适用性**: 对于解析树这种具有明确父子关系的结构，力导向图通常不是首选，因为它可能无法保持严格的层次感和清晰的对齐。然而，如果您的解析树需要更动态的布局或允许用户拖拽节点，并且对严格的垂直/水平对齐要求不高，可以考虑结合使用。

## 4. 解析树数据结构转换

解析树通常以嵌套对象或数组的形式表示。为了与 D3.js 的层次布局兼容，您需要将其转换为 `d3.hierarchy()` 可以处理的格式。这通常意味着每个节点对象需要包含一个 `children` 属性（如果存在子节点）。

```typescript
// 示例解析树节点结构
interface ParseTreeNode {
  name: string;
  children?: ParseTreeNode[];
  // 其他属性，如行号、列号等
}

// 转换为 D3.js 层次结构
const root = d3.hierarchy(parseTreeRootNode);
```

## 5. 新组件设计与切换机制

为了满足不修改原渲染组件并支持自由切换的需求，我们将采取以下策略：

*   **创建新组件 `D3ParseTree.tsx`**:
    *   我们将创建一个名为 `D3ParseTree.tsx` 的新 React 组件。
    *   这个组件将完全封装 D3.js 树状图的渲染逻辑。
    *   它将接收解析树数据作为 `props`，并在内部使用 `useEffect` 和 `useRef` 来管理 D3.js 的渲染生命周期和 SVG 容器。
    *   所有 D3.js 的初始化、更新和清理逻辑都将在这个组件内部完成。
*   **实现渲染组件切换机制**:
    *   在 `ParseTree.tsx` 的父组件中（根据文件列表，可能是 `App.tsx` 或 `EditorPanel.tsx`），我们将引入一个状态变量来控制当前应该渲染哪个组件。
    *   我们将添加一个用户界面元素（例如，一个按钮、下拉菜单或复选框），允许用户在原始的 `ParseTree.tsx` 和新的 `D3ParseTree.tsx` 之间进行切换。
    *   通过条件渲染（例如，使用三元运算符或 `if` 语句），根据状态变量的值来决定渲染哪个组件。

## 6. 详细实施计划

```mermaid
graph TD
    A[原始解析树数据] --> B{转换为 D3.js 层次数据};
    B --> C[创建 D3.js 树布局];
    C --> D{配置树布局参数};
    D --> E[计算节点和链接坐标];
    E --> F{后处理节点坐标 (可选，用于自定义对齐)};
    F --> G[渲染 SVG 元素 (节点和链接) 在 D3ParseTree.tsx 中];
    G --> H[添加交互功能 (缩放、平移、点击等) 到 D3ParseTree.tsx];

    SubGraph 渲染组件切换
        I[父组件 (例如 App.tsx 或 EditorPanel.tsx)] --> J{状态变量: currentRenderer};
        J --> K[UI 切换控件 (按钮/下拉菜单)];
        K --> J;
        J -- 条件渲染 --> L{ParseTree.tsx};
        J -- 条件渲染 --> M{D3ParseTree.tsx};
    End
```

**具体步骤：**

1.  **第一步：创建空组件和切换功能 (验证通过后再进行后续实现)**
    *   **创建 `D3ParseTree.tsx` 空组件**:
        *   在 `apps/web/src/grammar/components/` 目录下创建一个新文件 `D3ParseTree.tsx`。
        *   文件内容将是一个简单的 React 组件，它只渲染一个占位符，例如 `<div>D3 Parse Tree Placeholder</div>`。
    *   **修改父组件以实现切换**:
        *   识别 `ParseTree.tsx` 的父组件。根据文件列表，可能是 `apps/web/src/App.tsx` 或 `apps/web/src/components/EditorPanel.tsx`。
        *   在该父组件中，导入 `D3ParseTree.tsx`。
        *   引入一个 `useState` 钩子来管理当前选定的渲染器（例如，`const [renderer, setRenderer] = useState('original');`）。
        *   添加一个 UI 元素（例如，一个 `<button>` 或 `<select>`），当用户点击或选择时，更新 `renderer` 状态。
        *   使用条件渲染来根据 `renderer` 的值显示 `ParseTree` 或 `D3ParseTree` 组件，并将解析树数据作为 `props` 传递给它们。
    *   **验证**: 运行应用程序，确保可以通过 UI 控件成功切换到 `D3ParseTree.tsx` 组件，并看到占位符内容。

2.  **第二步：实现 `D3ParseTree.tsx` 中的 D3.js 渲染逻辑**
    *   在这个组件中，导入 D3.js 库。
    *   使用 `useRef` 创建一个 SVG 容器的引用。
    *   使用 `useEffect` 钩子来执行 D3.js 渲染逻辑：
        *   初始化 D3.js 树布局 (`d3.tree()`)。
        *   配置布局大小、节点大小和 `separation` 函数。
        *   **选择布局类型**: 根据用户选择（例如，通过 `props` 传递的 `layoutType`），决定使用矩形布局还是径向布局。
            *   对于矩形布局：`treeLayout.size([width, height]);`
            *   对于径向布局：`treeLayout.size([2 * Math.PI, radius]);` 并调整坐标转换。
        *   将解析树数据传递给布局并计算节点和链接的坐标。
        *   根据需要进行节点坐标的后处理以实现自定义对齐。
        *   将节点和链接渲染到 SVG 容器中。
        *   添加缩放、平移等交互功能。
    *   在 `useEffect` 的清理函数中，移除 D3.js 创建的元素或事件监听器，以防止内存泄漏。
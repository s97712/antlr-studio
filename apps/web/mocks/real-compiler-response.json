{
  "files": [
    {
      "name": "MyLexer.js",
      "content": "// Generated from MyLexer.g4 by ANTLR 4.13.1\r\n// jshint ignore: start\r\nimport antlr4 from 'antlr4';\r\n\r\n\r\nconst serializedATN = [4,0,3,24,6,-1,2,0,7,0,2,1,7,1,2,2,7,2,1,0,4,0,9,8,\r\n0,11,0,12,0,10,1,1,4,1,14,8,1,11,1,12,1,15,1,2,4,2,19,8,2,11,2,12,2,20,1,\r\n2,1,2,0,0,3,1,1,3,2,5,3,1,0,3,2,0,65,90,97,122,1,0,48,57,3,0,9,10,13,13,\r\n32,32,26,0,1,1,0,0,0,0,3,1,0,0,0,0,5,1,0,0,0,1,8,1,0,0,0,3,13,1,0,0,0,5,\r\n18,1,0,0,0,7,9,7,0,0,0,8,7,1,0,0,0,9,10,1,0,0,0,10,8,1,0,0,0,10,11,1,0,0,\r\n0,11,2,1,0,0,0,12,14,7,1,0,0,13,12,1,0,0,0,14,15,1,0,0,0,15,13,1,0,0,0,15,\r\n16,1,0,0,0,16,4,1,0,0,0,17,19,7,2,0,0,18,17,1,0,0,0,19,20,1,0,0,0,20,18,\r\n1,0,0,0,20,21,1,0,0,0,21,22,1,0,0,0,22,23,6,2,0,0,23,6,1,0,0,0,4,0,10,15,\r\n20,1,6,0,0];\r\n\r\n\r\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\r\n\r\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\r\n\r\nexport default class MyLexer extends antlr4.Lexer {\r\n\r\n    static grammarFileName = \"MyLexer.g4\";\r\n    static channelNames = [ \"DEFAULT_TOKEN_CHANNEL\", \"HIDDEN\" ];\r\n\tstatic modeNames = [ \"DEFAULT_MODE\" ];\r\n\tstatic literalNames = [  ];\r\n\tstatic symbolicNames = [ null, \"ID\", \"INT\", \"WS\" ];\r\n\tstatic ruleNames = [ \"ID\", \"INT\", \"WS\" ];\r\n\r\n    constructor(input) {\r\n        super(input)\r\n        this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.atn.PredictionContextCache());\r\n    }\r\n}\r\n\r\nMyLexer.EOF = antlr4.Token.EOF;\r\nMyLexer.ID = 1;\r\nMyLexer.INT = 2;\r\nMyLexer.WS = 3;\r\n\r\n\r\n\r\n"
    },
    {
      "name": "MyParser.js",
      "content": "// Generated from MyParser.g4 by ANTLR 4.13.1\r\n// jshint ignore: start\r\nimport antlr4 from 'antlr4';\r\nimport MyParserListener from './MyParserListener.js';\r\nconst serializedATN = [4,1,3,13,2,0,7,0,2,1,7,1,1,0,4,0,6,8,0,11,0,12,0,\r\n7,1,1,1,1,1,1,1,1,0,0,2,0,2,0,0,11,0,5,1,0,0,0,2,9,1,0,0,0,4,6,3,2,1,0,5,\r\n4,1,0,0,0,6,7,1,0,0,0,7,5,1,0,0,0,7,8,1,0,0,0,8,1,1,0,0,0,9,10,5,1,0,0,10,\r\n11,5,2,0,0,11,3,1,0,0,0,1,7];\r\n\r\n\r\nconst atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);\r\n\r\nconst decisionsToDFA = atn.decisionToState.map( (ds, index) => new antlr4.dfa.DFA(ds, index) );\r\n\r\nconst sharedContextCache = new antlr4.atn.PredictionContextCache();\r\n\r\nexport default class MyParser extends antlr4.Parser {\r\n\r\n    static grammarFileName = \"MyParser.g4\";\r\n    static literalNames = [  ];\r\n    static symbolicNames = [ null, \"ID\", \"INT\", \"WS\" ];\r\n    static ruleNames = [ \"prog\", \"stat\" ];\r\n\r\n    constructor(input) {\r\n        super(input);\r\n        this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);\r\n        this.ruleNames = MyParser.ruleNames;\r\n        this.literalNames = MyParser.literalNames;\r\n        this.symbolicNames = MyParser.symbolicNames;\r\n    }\r\n\r\n\r\n\r\n\tprog() {\r\n\t    let localctx = new ProgContext(this, this._ctx, this.state);\r\n\t    this.enterRule(localctx, 0, MyParser.RULE_prog);\r\n\t    var _la = 0;\r\n\t    try {\r\n\t        this.enterOuterAlt(localctx, 1);\r\n\t        this.state = 5; \r\n\t        this._errHandler.sync(this);\r\n\t        _la = this._input.LA(1);\r\n\t        do {\r\n\t            this.state = 4;\r\n\t            this.stat();\r\n\t            this.state = 7; \r\n\t            this._errHandler.sync(this);\r\n\t            _la = this._input.LA(1);\r\n\t        } while(_la===1);\r\n\t    } catch (re) {\r\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t\t        localctx.exception = re;\r\n\t\t        this._errHandler.reportError(this, re);\r\n\t\t        this._errHandler.recover(this, re);\r\n\t\t    } else {\r\n\t\t    \tthrow re;\r\n\t\t    }\r\n\t    } finally {\r\n\t        this.exitRule();\r\n\t    }\r\n\t    return localctx;\r\n\t}\r\n\r\n\r\n\r\n\tstat() {\r\n\t    let localctx = new StatContext(this, this._ctx, this.state);\r\n\t    this.enterRule(localctx, 2, MyParser.RULE_stat);\r\n\t    try {\r\n\t        this.enterOuterAlt(localctx, 1);\r\n\t        this.state = 9;\r\n\t        this.match(MyParser.ID);\r\n\t        this.state = 10;\r\n\t        this.match(MyParser.INT);\r\n\t    } catch (re) {\r\n\t    \tif(re instanceof antlr4.error.RecognitionException) {\r\n\t\t        localctx.exception = re;\r\n\t\t        this._errHandler.reportError(this, re);\r\n\t\t        this._errHandler.recover(this, re);\r\n\t\t    } else {\r\n\t\t    \tthrow re;\r\n\t\t    }\r\n\t    } finally {\r\n\t        this.exitRule();\r\n\t    }\r\n\t    return localctx;\r\n\t}\r\n\r\n\r\n}\r\n\r\nMyParser.EOF = antlr4.Token.EOF;\r\nMyParser.ID = 1;\r\nMyParser.INT = 2;\r\nMyParser.WS = 3;\r\n\r\nMyParser.RULE_prog = 0;\r\nMyParser.RULE_stat = 1;\r\n\r\nclass ProgContext extends antlr4.ParserRuleContext {\r\n\r\n    constructor(parser, parent, invokingState) {\r\n        if(parent===undefined) {\r\n            parent = null;\r\n        }\r\n        if(invokingState===undefined || invokingState===null) {\r\n            invokingState = -1;\r\n        }\r\n        super(parent, invokingState);\r\n        this.parser = parser;\r\n        this.ruleIndex = MyParser.RULE_prog;\r\n    }\r\n\r\n\tstat = function(i) {\r\n\t    if(i===undefined) {\r\n\t        i = null;\r\n\t    }\r\n\t    if(i===null) {\r\n\t        return this.getTypedRuleContexts(StatContext);\r\n\t    } else {\r\n\t        return this.getTypedRuleContext(StatContext,i);\r\n\t    }\r\n\t};\r\n\r\n\tenterRule(listener) {\r\n\t    if(listener instanceof MyParserListener ) {\r\n\t        listener.enterProg(this);\r\n\t\t}\r\n\t}\r\n\r\n\texitRule(listener) {\r\n\t    if(listener instanceof MyParserListener ) {\r\n\t        listener.exitProg(this);\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\nclass StatContext extends antlr4.ParserRuleContext {\r\n\r\n    constructor(parser, parent, invokingState) {\r\n        if(parent===undefined) {\r\n            parent = null;\r\n        }\r\n        if(invokingState===undefined || invokingState===null) {\r\n            invokingState = -1;\r\n        }\r\n        super(parent, invokingState);\r\n        this.parser = parser;\r\n        this.ruleIndex = MyParser.RULE_stat;\r\n    }\r\n\r\n\tID() {\r\n\t    return this.getToken(MyParser.ID, 0);\r\n\t};\r\n\r\n\tINT() {\r\n\t    return this.getToken(MyParser.INT, 0);\r\n\t};\r\n\r\n\tenterRule(listener) {\r\n\t    if(listener instanceof MyParserListener ) {\r\n\t        listener.enterStat(this);\r\n\t\t}\r\n\t}\r\n\r\n\texitRule(listener) {\r\n\t    if(listener instanceof MyParserListener ) {\r\n\t        listener.exitStat(this);\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\nMyParser.ProgContext = ProgContext; \r\nMyParser.StatContext = StatContext; \r\n"
    },
    {
      "name": "MyParserListener.js",
      "content": "// Generated from MyParser.g4 by ANTLR 4.13.1\r\n// jshint ignore: start\r\nimport antlr4 from 'antlr4';\r\n\r\n// This class defines a complete listener for a parse tree produced by MyParser.\r\nexport default class MyParserListener extends antlr4.tree.ParseTreeListener {\r\n\r\n\t// Enter a parse tree produced by MyParser#prog.\r\n\tenterProg(ctx) {\r\n\t}\r\n\r\n\t// Exit a parse tree produced by MyParser#prog.\r\n\texitProg(ctx) {\r\n\t}\r\n\r\n\r\n\t// Enter a parse tree produced by MyParser#stat.\r\n\tenterStat(ctx) {\r\n\t}\r\n\r\n\t// Exit a parse tree produced by MyParser#stat.\r\n\texitStat(ctx) {\r\n\t}\r\n\r\n\r\n\r\n}"
    }
  ]
}